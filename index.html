<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

    <title>Regular Expressions</title>

    <meta name="description" content="Regexes are Great">
		<meta name="author" content="James Gibson">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>
		<div class="reveal">
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Regexes</h1>
					<h3>Processing strings for the win!</h3>
          <p>
            <small>
              <a href="http://secondforge.com">James Gibson</a> </br>
              <a href="http://twitter.com/jamescgibson">@jamescgibson</a> </br>
              Sponsored by <a href="https://www.quottly.com">Quottly</a> </br>
            </small>
					</p>
				</section>

				<!-- Example of nested vertical slides -->
<section>
  <h2>What is a regular expression?</h2>
  <p>
    <ul>
      <li> "a sequence of characters that define a search pattern"</li>
      <li> "wildcards on steroids"</li>
      <li> "a way of desribing regular languages in formal language theory" </li>
    </ul>
  </p>

  <p>
  <i>the best way for you to manipulate strings</i>
</section>

<section data-markdown>
## Why do you care?
</section>

<section data-markdown>
##Do you use strings?
</section>

<section data-markdown>
  ## A sequence of characters

  ```
  /software/

  /[0-9]+/

  /(?<=[A-Z]{3})\s(?=\d{4})/
  ```
</section>

<section data-markdown>
## That define a search pattern


* Read the string from left to right, and for each character:
* Read the regex from left to right, checking if the characters match
* Stop and return false if the patterns don't match
* If you get to the end of the regex, they match! Stop.
* If you get to the end of the string, they don't!
</section>

<section data-markdown>
### Simplest Possible Example (JavaScript)

Let's check if a string matches a string

Could do this this way:

``` javascript
var string = "Hello Software Engineering Club!";
string.includes("Software"); //=> true
string.indexOf("Software") >= 0; //=> true
```
</section>


<section data-markdown>
### Simplest Possible Example

Or do it this way!

``` javascript
var string = "Hello Software Engineering Club!";
var regex = /software/;

regex.test(string) //=> false

var regex = /Software/
regex.test(string) //=> true
regex.exec(string) //=> ["Software"]
```
</section>

<section data-markdown>
### Simplest Possible Example (Java)

In Java

``` java
import java.util.regex.*;

// public class something or other ...

String string = "Hello Software Engineering Club!";
string.matches("software"); //=> false
string.matches("Software") >= 0; //=> true

// some more boilerplate
```
</section>

<section data-markdown>
### Elmer Fudd

Does this string contain "gum drops"?

``` javascript
var fudd = "They're all out of gum dwops?";
var you = "They're all out of gum drops?";

fudd.include("dwops") || fudd.include("drops"); //=> true
you.include("dwops") || you.include("drops"); //=> true
```
</section>
<section data-markdown>

``` javascript
var fudd = "They're all out of gum dwops?";
var you = "They're all out of gum drops?";

var regex = /gum d[rw]ops/;

regex.test(fudd); //=> true
regex.test(you); //=> true
regex.match(you); //=> ["drops"]
regex.match(fudd); //=> ["dwops"]

```

regex wins

</section>

<section data-markdown>
### Banning the catcaller

``` javascript
var catCaller1 = "Helloooo, Nurse!";
var catCaller2 = "Hellooooooo, Nurse!";
var respectful = "Hello there, Nurse Roberts!";
```
</section>

<section data-markdown>
### Without regexes:

``` javascript
var catCaller1 = "Helloooo, Nurse!";
var catCaller2 = "Hellooooooo, Nurse!";
var respectful = "Hello there, Nurse Roberts!";

function shouldBan(string) {
  return string.include("Helloo") && string.include("Nurse");
}

shouldBan(catCaller1); //=> true #RIGHT!
shouldBan(catCaller2); //=> true #RIGHT!
shouldBan(respectful); //=> false #RIGHT!

```
</section>

<section data-markdown>
### Without regexes:

``` javascript
var typo = "Helloo there, Nurse Roberts!";

function shouldBan(string) {
  return string.include("Helloo") && string.include("Nurse");
}

shouldBan(typo); /*=> true #WRONG */
```
</section>

<section data-markdown>
### Banning the Catcallers with Regexes

Match any number of 'o's

``` javascript
var catCaller1 = "Helloooo, Nurse!";
var catCaller2 = "Hellooooooo, Nurse!";
var respectful = "Hello there, Nurse Roberts!";
var typo = "Helloo there, Nurse Roberts!";

function shouldBan(string) {
  var regex = /Helloo+, Nurse/;
  return regex.test(string);
}

shouldBan(catCaller1); //=> true #RIGHT!
shouldBan(catCaller2); //=> true #RIGHT!
shouldBan(respectful); //=> false #RIGHT!
shouldBan(typo); //=> false #RIGHT!
```
</section>

<section data-markdown>
### You get the idea

```
\  -> Escape any of the characters below

*  -> Match 0 or more times
+  -> Match 1 or more times
?  -> Match 0 or 1 times

[] -> Match any character in the brackets
.  -> Match any character
$  -> Match the end of the input
^  -> Match the beginning of the input
```
</section>

<section data-markdown>
### Character Classes

Put a \ and make some magic

```
\d -> Any number
\D -> Any not-number
\s -> Any space
\w -> Any "word character" (letters, numbers, underscores),
\W -> Any non-word character
```

``` javascript
var string = "There are words here!
var regex = /\d/

regex.test(string) //=> false
```
</section>

<section data-markdown>
### Character Class Counts

{ } for the win

```
\d{1,3} -> 1 to 3 numbers
\d{2,} -> 2 or more numbers
\d{,5} -> Up to 5 numbers
\d{3} -> 3 NUmbers
```

``` javascript
var course name= "MAC 2311 Introduction to Calculus 1";
var regex = /[A-Z]{3}\s\d{4}/;

regex.test(string) //=> true
```
</section>

<section>
<section data-markdown>
### Matchgroups!

What if we want to just pull out a little something?

Put what we want to keep in `( )`

``` javascript
var regex = /Name:\s(.+)\sAge/;
var string = "Name: Tim Tebow Age: 28";

regex.exec(string); //=> ["Name: Tim Tebow", "Tim Tebow"]
```
</section>

<section data-markdown>
### Matchgroups!

``` javascript
var regex = /([A-Z]{3} \d{4})/;
var string = "MAC 2311 Intro to Calc 1 and PHY 2054 Physics";

string.match(regex); //=> ["MAC 2311", "MAC 2311"]
```
</section>

<section data-markdown>
### Go go global flag!

``` javascript
var regex = /([A-Z]{3} \d{4})/g;
var string = "MAC 2311 Intro Calc 1 and PHY 2054 Physics";

string.match(regex); //=> ["MAC 2311", "PHY 2054"]
```
</section>
</section>

<section>
<section data-markdown>
### Now you have two problems

> Some people, when confronted with a problem, think, "I know, I'll use regular expressions." Now they have two problems
>
> -Jamie Zawinksi via Jeff Atwood
</section>

<section data-markdown>
### NOT IF YOU TEST!

Confine your regexes to methods that have business meaning.

Write unit tests.

Write small regexes

(Seriously, lots of unit tests.)
</section>

<section data-markdown>
### Example from Quottly

``` ruby
def course_codes
  strings = remove_excess_spaces(text)
  strings.scan(/[^FGR]([A-Z]{3}\s*\d{4}\w*)/).map do |code|
    code.first.gsub(/\s/, "")
  end
end
```

``` ruby
it "matches a course code" do
  string = "Yadda Yadda ABC1234"
  expect(subject.course_codes).to include("ABC1234")
end

it "Doesn't match a year" do
  string = "Schedule Fall 2014"
  expect(subject.course_codes).to_not include("ALL2014")
end

it "Can batch an actual course code with a year-number" do
  string = "Course: ING 2013 English Lab"
  expect(subject.course_codes).to include("ING2013")
end
```
</section>
</section>

<section> <!-- dont regex html section -->
<section data-markdown>
# Gotchas
</section>

<section data-markdown>
### Don't Regex HTML

> You can't parse [X]TML with regex. Because HTML can't be parsed by regex. Regex is not a tool that can be used to correctly parse HTML.

[stackoverflow](http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags)
</section>

<section data-markdown>
### Unicode is not fun

``` javascript
var regex = /Name:\s(.+?)\s(.+?)/;
var string = "Name: Tim&nbsp;Tebow";

regex.test(string); //=> false #WHAT?
```
</section>
<section data-markdown>

``` javascript
var regex = /Name:\s(.+?)\s(.+?)/;
var string1 = "Name: Tim Tebow";
var string2= "Name: Tim&nbsp;Tebow";

regex.test(string1); //=> true
regex.test(string2); //=> false #WHAT?

string1.charCodeAt(9); => 32
string1.charCodeAt(9); => 160
```
</section>

<section data-markdown>
### Newlines aren't always included

``` javascript
var regex = /Name:\s(.+?)\s(.+?)/;
var string = "Name: Tim\nTebow";

regex.test(string); //=> true in javascript;
// false in Ruby, Python (?)

var regex = /Name:\s(.+?)\s(.+?)/m;
regex.test(string); //=> true
```
</section>

<section data-markdown>
### Matching all occurances can be odd, be careful

``` javascript
var regex1 = /Name:\s(.+?)\s(.+?)/;
var regex2 = /Name:\s(.+?)\s(.+?)/g;
var string = "Name: Tim Tebow\n Name: Chirs Leak";

string.exec(regex1); //=> ["Tim Tebow"]
string.exec(regex2); //=> ["Tim Tebow", "Chris Leak"]
```

(In many languages you call a different method to return all matches)
</section>
</section>

<section data-markdown>
# The End

Tell your friends about Quottly!

Ask me questions!
</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
